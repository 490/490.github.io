<!DOCTYPE html>




<html class="theme-next gemini" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="我的笔记">
<meta property="og:url" content="https://490.github.io/index.html">
<meta property="og:site_name" content="我的笔记">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我的笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://490.github.io/">





  <title>我的笔记</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">我的笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br>
            
            文章
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-vcard-o"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://490.github.io/计算机网络基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="le">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/计算机网络基础知识/" itemprop="url">计算机网络基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T10:51:16+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/计算机网络基础知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/计算机网络基础知识/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  30
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="一次完整的-HTTP-请求所经历的步骤？"><a href="#一次完整的-HTTP-请求所经历的步骤？" class="headerlink" title="一次完整的 HTTP 请求所经历的步骤？"></a>一次完整的 HTTP 请求所经历的步骤？</h2><p>即在浏览器中输入 URL 地址 &gt;&gt; 显示主页的过程。总体来说分为以下几个过程：</p>
<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>简单的来说，就是先经过下图的过程，将客户端的请求传到服务器，再经过下图过程的逆过程，将客户端请求的数据返回给客户端，然后客户端浏览器对返回的数据进行渲染，最终得到了我们看到的页面。</p>
<p><img src="./pic/浏览器发送请求到服务器的过程.jpg" alt="浏览器发送请求到服务器的过程.jpg"></p>
<h3 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h3><p>DNS 解析的过程就是寻找哪台机器上有你需要资源的过程。也就是说，把你输入的 URL 地址转换为 IP 地址。</p>
<h3 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h3><p>客户端 (浏览器) 通过 TCP 传输协议建立到服务器的 TCP 连接，详见后面 TCP 是如何传输数据，以及三次握手和四次挥手等。</p>
<h3 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h3><p>发送 HTTP 请求的过程就是构建 HTTP 请求报文并通过 TCP 协议中发送到服务器指定端口 (HTTP 协议 80/8080，HTTPS 协议443)。HTTP 请求报文是由三部分组成： <strong>请求行</strong> 、 <strong>请求报头</strong> 、 <strong>请求正文 </strong>。</p>
<h3 id="服务器处理请求并返回-HTTP-报文"><a href="#服务器处理请求并返回-HTTP-报文" class="headerlink" title="服务器处理请求并返回 HTTP 报文"></a>服务器处理请求并返回 HTTP 报文</h3><p>后端从固定的端口接收到 TCP 报文（这一部分对应于编程语言中的 socket），它会对 TCP 连接进行处理，对 HTTP 协议进行解析，并按照报文格式进一步封装成 HTTP Request 对象，供上层使用。这一部分工作一般是由 Web 服务器去进行，我使用过的  Web 服务器有 Tomcat，Jetty。</p>
<p>HTTP 响应报文也是由三部分组成： <strong>状态码</strong> 、 <strong>响应报头</strong> 、 <strong>响应报文</strong> 。</p>
<blockquote>
<p><strong>状态码：</strong></p>
<ul>
<li>1xx：指示信息–表示请求已接收，继续处理。</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求。</li>
</ul>
</blockquote>
<h3 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h3><p>即浏览器收到 HTML、CSS、JS 文件后，把页面呈现到屏幕上的过程。</p>
<h2 id="DNS-解析-1"><a href="#DNS-解析-1" class="headerlink" title="DNS 解析"></a>DNS 解析</h2><p>DNS 解析的过程就是寻找哪台机器上有你需要资源的过程。也就是说，把你输入的 URL 地址转换为 IP 地址。</p>
<p>DNS 域名解析过程如下图所示，简单来说就是先查自己的本地域名服务器，如果自己就有缓存，直接从缓存里面读就可以，如果缓存里没有，本地域名服务器会发出递归连环问去查找。</p>
<p><img src="./pic/DNS域名解析过程.png" alt="DNS域名解析过程.png"></p>
<p><strong>DNS 负载均衡</strong></p>
<p>DNS 可以根据每台机器的负载量，该机器离用户地理位置的距离等等，返回一个合适的机器的 IP 给用户，这个过程就是 DNS 负载均衡，又叫做 DNS 重定向。大家耳熟能详的 CDN (Content Delivery Network) 就是利用 DNS 的重定向技术实现的，DNS 服务器会返回一个跟用户最接近的服务器的 IP 地址给用户，CDN 节点的服务器负责响应用户的请求。</p>
<h2 id="CDN（Content-Distribute-Network）"><a href="#CDN（Content-Distribute-Network）" class="headerlink" title="CDN（Content Distribute Network）"></a>CDN（Content Distribute Network）</h2><p>CDN，内容分发网络。最简单的 CDN 网络由一个 DNS 服务器和几台缓存服务器组成：</p>
<ul>
<li>当用户点击网站页面上的内容 URL，经过本地 DNS 系统解析，DNS 系统会最终将域名的解析权交给 CNAME 指向的 CDN 专用 DNS 服务器。</li>
<li>CDN 的 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回用户。</li>
<li>用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。</li>
<li>CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的区域负载均衡设备，告诉用户这台服务器的 IP 地址，让用户向这台设备发起请求。选择的依据包括：<ul>
<li>根据用户 IP 地址，判断哪一台服务器距用户最近；</li>
<li>根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；</li>
<li>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力；</li>
</ul>
</li>
<li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。</li>
<li>如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li>
</ul>
<h2 id="TCP-是如何传输数据的？"><a href="#TCP-是如何传输数据的？" class="headerlink" title="TCP 是如何传输数据的？"></a>TCP 是如何传输数据的？</h2><p>TCP (Transmission Control Protocol, TCP)，是一种面向连接、确保数据在端到端间可靠传输的协议。在传输前需要先建立一条可靠的传输链路，然后让数据在这条链路上流动，完成传输。简单来说就是，TCP 在想尽各种办法保证数据传输的可靠性，为了可靠性 TCP 会这样进行数据传输：</p>
<ul>
<li>三次握手建立连接；</li>
<li>对发出的每一个字节进行编号确认，校验每一个数据包的有效性，在出现超时进行重传；</li>
<li>通过流量控制（通过滑动窗口协议实现）和拥塞控制（慢启动和拥塞避免、快重传和快恢复）等机制，避免网络状况恶化而影响数据传输；</li>
<li>四次挥手断开连接。</li>
</ul>
<h2 id="TCP-报头结构"><a href="#TCP-报头结构" class="headerlink" title="TCP 报头结构"></a>TCP 报头结构</h2><p><strong>TCP 头部长度的前 20 字节是固定的，后面部分长度不定，但最多 40 字节</strong> ，因此 TCP 头部一般在 20 ~ 60 字节之间。它的结构图如下：</p>
<p><img src="./pic/TCP的头部.png" alt="TCP的头部.png"></p>
<p><strong>它的每一字段的说明如下：</strong></p>
<ul>
<li><strong>0 ~ 32 比特：源端口和目的端口</strong> ，各占 16 比特（2 字节）。</li>
<li><strong>32 ~ 64 比特：序列号 seq</strong> ，当前 TCP 数据报数据部分的第一个字节的序号（4 字节）。</li>
<li><strong>64 ~ 96 比特：确认序号 ack</strong> ，表示当前主机作为接收端时，下一个希望接收的序列号是多少，确认号 = 当前主机已经正确接收的最后一个字节的序列号 + 1</li>
<li><strong>96 ~ 112 比特：数据报报头长度，保留字段，标识符。</strong><ul>
<li>标识符：用于表示 TCP 报文的性质，只能是 0 或 1。TCP 的常用标识符：<ul>
<li><code>URG=1</code>：紧急指针有效性标志，表示本数据报的数据部分包含紧急信息，紧急数据一定位于当前数据包数据部分的最前面，后面的紧急指针则标明了紧急数据的尾部。</li>
<li><code>ACK=1</code>：在连接建立后传送的所有报文段都必须把 ACK 置 1，也就是说 <code>ACK=1</code> 后确认号字段才有效。</li>
<li><code>PSH=1</code>：接收方应尽快将报文段提交至应用层，不会等到缓冲区满后再提交，一些交互式应用需要这样的功能，降低命令的响应时间。</li>
<li><code>RST=1</code>：当该值为 1 时，表示当前 TCP 连接出现严重问题，必须要释放重连。</li>
<li><code>SYN=1</code>：用在建立连接时<ul>
<li><code>SYN=1, ACK=0</code>：当前报文段是一个连接请求报文。</li>
<li><code>SYN=1, ACK=1</code>：表示当前报文段是一个同意建立连接的应答报文。</li>
</ul>
</li>
<li><code>FIN=1</code>：表示此报文段是一个释放连接的请求报文。</li>
</ul>
</li>
</ul>
</li>
<li><strong>112 ~ 128 比特：接收窗口大小</strong> ，该字段用于实现 TCP 的流量控制。<ul>
<li>它表示当前接收方的接收窗口的剩余大小，发送方收到该值后会将发送窗口调整成该值的大小（收到一个数据报就调整一次）。发送窗口的大小又决定了发送速率，所以接收方通过设置该值就可以控制发送放的发送速率。</li>
</ul>
</li>
<li><strong>128 ~ 144 比特：校验和</strong> ，用于接收端检验整个数据包在传输过程中是否出错。</li>
<li><strong>144 ~ 160 比特：紧急指针</strong> ， 用来标明紧急数据的尾部，和 URG 标识符一起使用。</li>
</ul>
<h2 id="什么是-TCP-三次握手、四次挥手？"><a href="#什么是-TCP-三次握手、四次挥手？" class="headerlink" title="什么是 TCP 三次握手、四次挥手？"></a>什么是 TCP 三次握手、四次挥手？</h2><ul>
<li>TCP 的三次握手：为了建立可靠的通信信道，即双方确认自己与对方的发送和接收都是正常的。</li>
<li>TCP 的四次挥手：确保双方都在没有想说的内容之后，释放 TCP 连接。</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><h4 id="三次握手的流程"><a href="#三次握手的流程" class="headerlink" title="三次握手的流程"></a>三次握手的流程</h4><p><img src="./pic/三次握手流程.jpg" alt="三次握手流程.jpg"></p>
<ul>
<li>第一次握手：A 向 B 发送建立连接请求（A 对 B 说：“我们在一起吧！”）</li>
<li>第二次握手：B 收到 A 的建立连接请求后，发给 A 一个同意建立连接的应答报文（B 对 A 说：“好的，同意和你在一起啦”）</li>
<li>第三次握手：A 向 B 发送个报文，表示我已经收到你的应答了（A 对 B 说：“亲爱的，你同意真是太好了，我们可以互相砸数据了”）</li>
</ul>
<h4 id="为什么-TCP-连接需要三次握手，两次不可以吗？"><a href="#为什么-TCP-连接需要三次握手，两次不可以吗？" class="headerlink" title="为什么 TCP 连接需要三次握手，两次不可以吗？"></a>为什么 TCP 连接需要三次握手，两次不可以吗？</h4><p>首先，我们要知道，这三次握手是为了让双方确认自己与对方的发送和接收都是正常的。但是，只成功完成两次握手的时候，B 不知道自己的发送能力是否正常，也不知道 A 的收报能力是否正常，所以它们需要第三次握手。</p>
<p>同时，如果没有第三次连接，很有可能导致 B 建立一个脏连接。</p>
<p><strong>脏连接建立的过程：</strong></p>
<p><img src="./pic/两次握手流程脏连接建立流程.jpg" alt="两次握手流程脏连接建立流程.jpg"></p>
<ul>
<li>A 发送的第一个建立连接的请求，这个连接好久好久都没有达到 B 那里；</li>
<li>所以，A 又重新发送了一个新的建立连接请求给 B，这个请求成功了，A 和 B 愉快的交换完了数据并且断开了连接；</li>
<li>此时，A 第一个发的建立连接的请求终于穿越 n 个路由器到达了 B，B 以为这时 A 发来的新的建立连接的请求，愉快的返回了同意建立连接的请求；</li>
<li>如果只需要两次握手，此时 B 会单方面的建立起与 A 的连接，而 A 根本就不在 SYN_SENT 状态，它会把 B 的应答请求直接丢掉，不会建立连接。此时，B单方面创建的这个连接就是脏连接。</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><h4 id="四次挥手的流程"><a href="#四次挥手的流程" class="headerlink" title="四次挥手的流程"></a>四次挥手的流程</h4><p><img src="./pic/四次挥手流程.jpg" alt="四次挥手流程.jpg"></p>
<ul>
<li>A：我们分手吧。</li>
<li>B：好的，我收到了你的分手请求，再等一会，我把你剩我这的东西打包给你。（此时 A 已经不能再给 B 发东西了）</li>
<li>B：好了，东西发完了，分吧。（此时 B 也不能再给 A 发东西了）</li>
<li>A：好的，知道你东西都发完了，我在等 2MSL，然后就消失了。</li>
</ul>
<h4 id="TIME-WAIT-存在的必要性"><a href="#TIME-WAIT-存在的必要性" class="headerlink" title="TIME_WAIT 存在的必要性"></a>TIME_WAIT 存在的必要性</h4><p>如果 A 发送完最后一个 <code>ACK=1</code> 后，立即进入 CLOSED 状态，可能会导致 B 无法进入 CLOSED 状态。</p>
<p>原因：假设 A 最后的 ACK 在网络传输中丢失了，B 会认为 A 根本没收到自己发的 <code>FIN=1, ACK=1</code> 报文，会导致 B 超时重发 <code>FIN=1, ACK=1</code> 报文。A 第二次收到 <code>FIN=1, ACK=1</code> 报文后，会再发一次 ACK，并重新开始 TIME_WAIT 的计时。如果 A 发完最后一个 ACK 后立即关闭，B 可能会永远接收不到最后一个 ACK，也就无法进入 CLOSED 状态。</p>
<blockquote>
<p>在高并发上，可以将 TIME_WAIT 调到小于 30s 为宜。</p>
<p>设置方法：改变服务器的配置文件 /etc/sysctl.conf 中的 <code>net.ipv4.tcp_fin_timeout=30</code></p>
</blockquote>
<p><em>注：seq 表示序列号，ack 表示确认号，2MSL 是报文在网络中生存的最长时间。</em></p>
<h2 id="TCP-如何进行流量控制、拥塞控制？"><a href="#TCP-如何进行流量控制、拥塞控制？" class="headerlink" title="TCP 如何进行流量控制、拥塞控制？"></a>TCP 如何进行流量控制、拥塞控制？</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><strong>产生原因：</strong> 如果发送方数据发送的过快，接收方可能来不及接收，这会造成数据的丢失。</p>
<p><strong>解决方法：</strong> 通过滑动窗口实现，接收端告诉发送发自己的接收窗口有多大，发送端会调整自己的发送窗口不超过接收端的接收窗口大小。</p>
<p><strong>流量控制引发的死锁：</strong> 当发送者收到了一个窗口为 0 的应答后，发送者会停止发送，等待接收者的下一个应答。但是如果这个窗口不为 0 的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><h4 id="慢启动和拥塞避免"><a href="#慢启动和拥塞避免" class="headerlink" title="慢启动和拥塞避免"></a>慢启动和拥塞避免</h4><p>首先，发送方维持一个叫做 <strong>拥塞窗口 cwnd（congestion window）</strong> 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于 <code>min{拥塞窗口, 接收窗口}</code>。</p>
<p><strong>慢启动就是：</strong> 不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。具体过程如下：</p>
<p><img src="./pic/TCP慢启动.jpg" alt="TCP慢启动.jpg"></p>
<p>慢启动的时候，拥塞窗口每次是呈 2 的指数次方增长的，因为开始的时候需要比较快速的将拥塞窗口的大小增长到一个合适值。如果我们一直使用慢启动的方法确认拥塞窗口 cwnd 的大小，cwnd 会飞速增大，而且增长的粒度会越来越粗，一不小心就增的过大了，就会导致网络的拥塞。</p>
<p>为了避免这种情况，我们设定了一个慢开始门限 ssthresh，令 cwnd 大于一定值之后就采用拥塞避免算法，拥塞避免算法和慢启动算法的区别在于：拥塞避免算法每次只将 cwnd 增加 1，也就是呈加法增长的。ssthresh 的用法如下：</p>
<ul>
<li>cwnd &lt; ssthresh 时，使用慢开始算法</li>
<li>cwnd &gt; ssthresh 时，改用拥塞避免算法</li>
<li>cwnd = ssthresh时，慢开始与拥塞避免算法任意</li>
</ul>
<p>拥塞避免算法会让拥塞窗口缓慢增长，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。</p>
<p>无论是在 <strong>慢启动阶段</strong> 还是在 <strong>拥塞避免阶段</strong> ，只要发送方判断 <strong>网络出现拥塞</strong> （其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理）， <strong>就把慢开始门限设置为出现拥塞时的发送窗口大小的一半（乘法减小算法）。然后把拥塞窗口设置为 1，执行慢开始算法。</strong> </p>
<p>通过使用慢启动与拥塞避免算法，拥塞窗口的大小变化大致如下图所示：</p>
<p><img src="./pic/cwnd大小变化.jpg" alt="cwnd大小变化.jpg"></p>
<p><em>注：这里只是为了讨论方便而将拥塞窗口大小的单位改为数据报的个数，实际上应当是字节。</em></p>
<h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p><strong>快重传</strong> 要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不等到自己发送数据时捎带确认。</p>
<p>快重传算法规定：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传时间计时器到期。如下图：</p>
<p><img src="./pic/快重传过程.png" alt="快重传过程.png"></p>
<p><strong>快恢复</strong> 要求当发送发连续接收到三个确认时，就执行乘法减小算法，把慢启动开始门限（ssthresh）减半，但是接下来并不执行慢开始算法。而是将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免算法。</p>
<p>通过使用快重传与快恢复算法，拥塞窗口的大小变化大致如下图所示：</p>
<p><img src="./pic/快重传与快恢复.png" alt="快重传与快恢复.png"></p>
<h2 id="什么是-TCP-滑动窗口？"><a href="#什么是-TCP-滑动窗口？" class="headerlink" title="什么是 TCP 滑动窗口？"></a>什么是 TCP 滑动窗口？</h2><h3 id="停止等待协议（ARQ-协议，滑动窗口协议的简易版）"><a href="#停止等待协议（ARQ-协议，滑动窗口协议的简易版）" class="headerlink" title="停止等待协议（ARQ 协议，滑动窗口协议的简易版）"></a>停止等待协议（ARQ 协议，滑动窗口协议的简易版）</h3><p><strong>原理：</strong></p>
<ul>
<li>A 向 B 每发送一个分组，都要停止发送，等待 B 的确认应答；A 只有收到了 B 的确认应答后才能发送下一个分组。</li>
</ul>
<p><strong>A 发送的分组丢失或出错</strong></p>
<ul>
<li>丢失：发送者 A 拥有超时计时器。每发送一个分组便会启动超时计时器，等待 B 的应答。若超时仍未收到应答，A 就会重发刚才的分组。</li>
<li>出错：若 B 收到分组，但通过检查和字段发现分组在运输途中出现差错，它会直接丢弃该分组，并且不会有任何其他动作。A 超时后便会重新发送该分组，直到 B 正确接收为止。</li>
</ul>
<p><strong>B 发送的确认应答丢失或迟到</strong></p>
<ul>
<li>丢失：A 迟迟收不到 B 的确认应答，会进行超时重传，B 收到重复的分组后会立即补发一个确认应答。</li>
<li>迟到：A 会根据分组号得知该分组已被接收，会直接丢弃该应答。</li>
</ul>
<h3 id="滑动窗口协议（连续-ARQ-协议）"><a href="#滑动窗口协议（连续-ARQ-协议）" class="headerlink" title="滑动窗口协议（连续 ARQ 协议）"></a>滑动窗口协议（连续 ARQ 协议）</h3><p><strong>ARQ 协议的缺点：</strong> 每次只发送一个分组，在该分组的应答到来前只能等待。为了解决这个问题，我们改成一次发送一堆，也就是我们有个窗口，在发送端没有收到确认应答时，可以继续发送窗口中的分组，而不是干等着。</p>
<p><strong>累计确认：</strong> 接收端不用为每一个分组发送一个应答了，改为为一组分组发送一个确认应答。这个应答会通过 TCP 头中的 ack（确认号）来告诉发送端它下一个希望接收的分组号是多少。</p>
<p><strong>发送窗口：</strong></p>
<p><img src="./pic/发送窗口.jpg" alt="发送窗口.jpg"></p>
<p>发送端收到接收端发来的一个确认应答后，会根据确认应答的 TCP 头中的各种信息移动 P1、P2、P3 三个指针：</p>
<ul>
<li>根据 ack 的值移动 P1 指针，确认哪些分组被成功接收了；</li>
<li>然后根据窗口大小移动 <code>P3 = P1 + 窗口大小</code>；</li>
<li>然后 P2 从 P1 开始向 P3 移动，向接收端发送分组数据。</li>
</ul>
<p><strong>接收窗口：</strong></p>
<p><img src="./pic/接收窗口.jpg" alt="接收窗口.jpg"></p>
<ul>
<li>接收者收到的字节会存入接收窗口，接收者会对已经正确接收的有序字节进行累计确认，发送完确认应答后，接收窗口就可以向前移动指定字节。</li>
<li>如果某些字节并未按序收到，接收者只会确认最后一个有序的字节，从而乱序的字节就会被重新发送。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>同一时刻发送窗口的大小并不一定和接收窗口一样大（因为时延和拥塞窗口）。</li>
<li>TCP 标准并未规定未按序到达的字节的处理方式。但 TCP 一般都会缓存这些字节，等缺少的字节到达后再交给应用层处理（应用层可以对它进行排序）。这比直接丢弃乱序的字节要节约带宽。</li>
</ul>
<h2 id="TCP-与-UDP-的区别？"><a href="#TCP-与-UDP-的区别？" class="headerlink" title="TCP 与 UDP 的区别？"></a>TCP 与 UDP 的区别？</h2><p><strong>从特点上看：</strong></p>
<ul>
<li>TCP 是面向连接的，UDP 是无连接的，即<ul>
<li>TCP 在传输数据前要先通过三次握手建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制建立连接，数据传输结束后要释放连接。</li>
<li>UDP 在传输数据前不需要建立连接，远地主机在接收到报文之后也无需确认。</li>
</ul>
</li>
<li>所以 TCP 是可靠传输，UDP 是不可靠传输。</li>
<li>TCP 因为有连接，所以数据以字节流的形式传输，UDP 则以数据报文段形式传输，而且 TCP 只能是一对一的，而 UDP 可以各种通信。</li>
</ul>
<p><strong>从性能上看：</strong> TCP 传输效率慢，需要资源多，但可靠。UDP 传输效率快，需要资源少，但不可靠。</p>
<p><strong>应用场景：</strong> TCP 应用在要求传输数据可靠的情况下，如文件传输、邮件传输等。UDP 应用在要求通信速度但对可靠性要求比较低的场景，如 QQ 语音、视频等。</p>
<p><strong>首部字节：</strong> TCP 首部有 20 ~ 60 个字节，UDP 首部由 8 个字节 4 个字段组成。</p>
<p><strong>怎么用 UDP 实现 TCP？</strong></p>
<p>在传输层 UDP 是不可靠的，所以需要在应用层自己实现一些保证可靠传输的机制，简单来说，就是使用 UDP 来构建可靠的面向连接的数据传输，就是在应用层实现类似于 TCP 的超时重传（定时器），拥塞控制（滑动窗口），有序接收（添加包序号），应答确认（ack 和 seq）等。目前已经有了实现 UDP 可靠运输的机制 —— UDT：主要用于高速广域网海量数据传输，是应用层协议。</p>
<h2 id="HTTP-长连接、短连接？"><a href="#HTTP-长连接、短连接？" class="headerlink" title="HTTP 长连接、短连接？"></a>HTTP 长连接、短连接？</h2><h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><p>在 HTTP/1.0 中默认使用 <strong>短连接：客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。</strong> 当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等）时，浏览器就会重新建立一个 HTTP 会话。</p>
<p><strong>应用：</strong> WEB 网站的 http 服务一般都用短链接，因为并发量大，但每个用户无需频繁操作。</p>
<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>而从 HTTP/1.1 起，默认使用长连接。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>
<p><strong>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</strong> Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接，有关 TCP 长连接、短连接的介绍请看下一小节。</p>
<p><strong>应用：</strong> 适用于操作频繁的点对点通讯，而且连接数不能太多。</p>
<h2 id="TCP-长连接、短连接？"><a href="#TCP-长连接、短连接？" class="headerlink" title="TCP 长连接、短连接？"></a>TCP 长连接、短连接？</h2><h3 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h3><p><strong>短连接过程：</strong> client 向 server 发起连接请求，server 接到请求，然后双方建立连接。client 向 server 发送消息，server 回应 client，然后一次请求就完成了。这时候双方任意都可以发起 close 操作，不过一般都是 client 先发起 close 操作。也就是说，短连接一般只会在 client 和 server 间进行一次请求操作。</p>
<p><strong>优点：</strong> 管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。</p>
<p><strong>缺点：</strong> 如果客户请求频繁，将在 TCP 的建立和关闭操作上浪费时间和带宽。</p>
<h3 id="长连接-1"><a href="#长连接-1" class="headerlink" title="长连接"></a>长连接</h3><p><strong>长连接过程：</strong> client 向 server 发起连接，server 接受 client 连接，双方建立连接，client 与 server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>
<p>TCP 的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。</p>
<p>如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测 4 个客户端状态：</p>
<ul>
<li>客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应 TCP。服务端将无法收到客户端对探测的响应。服务器总共发送 10 个这样的探测，每个间隔 75 秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。</li>
<li>客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li>
<li>客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。</li>
</ul>
<p><strong>优点：</strong> 对于请求比较频繁客户来说，可以节省在 TCP 的建立和关闭操作上浪费时间和带宽。</p>
<p><strong>缺点：</strong> 存活探测周期太长，而且 client 端一般不会主动关闭它与服务器之间的连接，如果 <strong>client 与 server 之间的连接一直不关闭的话，随着客户端连接越来越多，server 早晚有扛不住的时候</strong> ，这时候 server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，以避免一些恶意连接导致 server 端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p>
<h2 id="HTTP、HTTPS-区别？"><a href="#HTTP、HTTPS-区别？" class="headerlink" title="HTTP、HTTPS 区别？"></a>HTTP、HTTPS 区别？</h2><p>HTTPS 的全称为：HTTP over SSL，简单理解就是在之前的 HTTP 传输上增加了 SSL 协议加密。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|------|  </span><br><span class="line">| HTTP |</span><br><span class="line">|------| &lt;-- HTTPS 在 HTTP 和 TCP 间加了一层 SSL or TLS</span><br><span class="line">| TCP  |</span><br><span class="line">|------|</span><br><span class="line">|  IP  |</span><br><span class="line">|------|</span><br></pre></td></tr></table></figure>
<h3 id="HTTP-通信存在的问题"><a href="#HTTP-通信存在的问题" class="headerlink" title="HTTP 通信存在的问题"></a>HTTP 通信存在的问题</h3><ul>
<li><strong>容易被监听：</strong> http 通信都是明文，数据在客户端与服务器通信过程中，任何一点都可能被劫持，如果明文保存的密码被截取了是很危险的。</li>
<li><strong>被伪装：</strong> http 通信时无法保证双方是合法的。比如你请求 <a href="http://www.taobao.com，你无法知道返回的数据就是来自淘宝，还是中间人伪装的淘宝。" target="_blank" rel="noopener">www.taobao.com，你无法知道返回的数据就是来自淘宝，还是中间人伪装的淘宝。</a></li>
<li><strong>被篡改：</strong> 中间人将发给你的信息篡改了你也不知道。</li>
</ul>
<p>因为 http 不安全，所以 https 出现了！</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>HTTPS 需要到 CA 申请证书，HTTP 不需要</li>
<li>HTTPS 密文传输，HTTP 明文传输</li>
<li>连接方式不同，HTTPS 默认使用 443 端口，HTTP 使用 80 端口</li>
<li>HTTPS = HTTP + 加密 + 认证 + 完整性保护，比 HTTP 安全</li>
</ul>
<h2 id="HTTP-1-1-与-HTTP-1-0-的区别？"><a href="#HTTP-1-1-与-HTTP-1-0-的区别？" class="headerlink" title="HTTP 1.1 与 HTTP 1.0 的区别？"></a>HTTP 1.1 与 HTTP 1.0 的区别？</h2><ul>
<li>1.0 需要设置 keep-alive 参数来告知服务器建立长连接，1.1 默认建立长连接。</li>
<li>1.1 支持只发 header 不带 body，如果服务器认为客户端有权利访问，返回 100，否则返回 401，客户端可以接到 100 后再把 body 发过去，接到 401 就不发了，这样比较节省带宽。</li>
<li>1.1 有 host 域，1.0 没有。<ul>
<li>host 域用于处理一个IP地址对应多个域名的情况，假设我的虚拟机服务器 IP 是 111.111.111.111，我们可以把 <a href="http://www.qiniu.com，www.taobao.com" target="_blank" rel="noopener">www.qiniu.com，www.taobao.com</a> 和 <a href="http://www.jd.com" target="_blank" rel="noopener">www.jd.com</a> 这些网站都架设那台虚拟机上面，但是这样会有一个问题，我们每次访问这些域名其实都是解析到服务器 IP 111.111.111.111，那么如何来区分每次根据域名显示出不同的网站的内容呢？就是通过 Host 域的设置，可以在 Tomcat 的 conf 目录下的 server.xml 进行配置。</li>
</ul>
</li>
<li>1.1 会进行带宽优化。1.0 存在浪费带宽的现象，而且不支持断点续传，1.1 在请求头中引入了 range 域，允许只请求某个资源的某个部分，即返回状态码 206。</li>
</ul>
<h2 id="如果客户端不断的发送请求连接会怎样？"><a href="#如果客户端不断的发送请求连接会怎样？" class="headerlink" title="如果客户端不断的发送请求连接会怎样？"></a>如果客户端不断的发送请求连接会怎样？</h2><p>服务器端会为每个请求创建一个链接，然后向 client 端发送创建连接时的回复，然后进行等待客户端发送第三次握手数据包，这样会白白浪费资源。DDos 攻击就是基于这一点达到的。</p>
<h3 id="DDos-攻击"><a href="#DDos-攻击" class="headerlink" title="DDos 攻击"></a>DDos 攻击</h3><p>简单的说就是不停的向服务器发送建立连接请求，但不发送第三次握手的数据包。</p>
<ul>
<li>客户端向服务器端发送连接请求数据包</li>
<li>服务器向客户端回复连接请求数据包，然后服务器等待客户端发送tcp/ip链接的第三步数据包</li>
<li>如果客户端不向服务器端发送最后一个数据包，服务器须等待 30s 到 2min 才能将此连接关闭。当大量的请求只进行到第二步，而不进行第三步，服务器将有大量的资源在等待第三个数据包，造成DDos攻击。</li>
</ul>
<h3 id="DDos-预防"><a href="#DDos-预防" class="headerlink" title="DDos 预防"></a>DDos 预防</h3><ul>
<li>DDoS清洗：对用户请求数据进行实时监控，及时发现异常流量，封掉异常流量的 IP，使用的命令：<code>iptables</code>。<ul>
<li>用 <code>iptables</code> 屏蔽单个 IP 的命令：<code>iptables -I INPUT -s ***.***.***.*** -j DROP</code></li>
<li>用 <code>iptables</code> 屏蔽整个 IP 段命令：<code>iptables -I INPUT -s 121.0.0.0/8 -j DROP</code></li>
<li>用 <code>iptables</code> 解禁 IP 命令：<code>iptables -D INPUT -s ***.***.***.*** -j DROP</code></li>
<li>相当于在 /etc/iptables.conf 配置文件中写入：<code>-A INPUT -s ***.***.***.*** -j DROP</code></li>
</ul>
</li>
<li>CDN 加速：在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 DDoS 攻击，也可以将流量分散到各个节点中，防止源站崩溃。</li>
</ul>
<h2 id="GET-和-POST-区别？"><a href="#GET-和-POST-区别？" class="headerlink" title="GET 和 POST 区别？"></a>GET 和 POST 区别？</h2><ul>
<li>Http 报文层面：GET 将请求信息放在 URL 中，POST 方法报文中，所以 POST 方法更安全，毕竟数据在地址栏上不可见。</li>
<li>数据库层面：GET 符合幂等性，POST 不符合。</li>
<li>缓存层面：GET 可以被缓存、被存储（书签），而 POST 不行。</li>
</ul>
<h2 id="什么是-301、302-重定向？"><a href="#什么是-301、302-重定向？" class="headerlink" title="什么是 301、302 重定向？"></a>什么是 301、302 重定向？</h2><p><strong>HTTP 返回码中 301 和 302 的区别：</strong></p>
<ul>
<li>301，302 都是 HTTP 的状态码，都代表着某个 URL 发生了转移，不同之处在于：<ul>
<li>301 代表永久性转移 (Permanently Moved)。</li>
<li>302 代表暂时性转移(Temporarily Moved )。搜索引擎会抓取新的内容而保留旧的网址，因为服务器返回 302 代码，搜索引擎认为新的网址只是暂时的。</li>
</ul>
</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>域名到期不想续费；</li>
<li>在搜索引擎的搜索结果中出现了不带 www 的域名，而带 www 的域名却没有收录，这个时候可以用 301 重定向来告诉搜索引擎我们目标的域名是哪一个；</li>
<li>空间服务器不稳定，换空间的时候。</li>
</ul>
<p><strong>注意：尽量使用 301 跳转！原因：网址劫持！</strong></p>
<p>从网址 A 做一个 302 重定向到网址 B 时，主机服务器的隐含意思是网址 A 随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到 302 重定向时，一般只要去抓取目标网址就可以了，也就是说网址 B。如果搜索引擎在遇到 302 转向时，百分之百的都抓取目标网址 B 的话，就不用担心网址 URL 劫持了。问题就在于，有的时候搜索引擎，尤其是 Google，并不能总是抓取目标网址。比如说，有的时候 A 网址很短，但是它做了一个 302 重定向到 B 网址，而 B 网址是一个很长的乱七八糟的 URL 网址，甚至还有可能包含一些问号之类的参数。很自然的，A 网址更加用户友好，而 B 网址既难看，又不用户友好。这时 Google 很有可能会仍然显示网址A。</p>
<p>这就造成了网址 URL 劫持的可能性。也就是说，一个不道德的人在他自己的网址 A 做一个 302 重定向到你的网址 B，出于某种原因， Google 搜索结果所显示的仍然是网址 A，但是所用的网页内容却是你的网址 B 上的内容，这种情况就叫做网址 URL 劫持。你辛辛苦苦所写的内容就这样被别人偷走了。</p>
<p>302 重定向很容易被搜索引擎误认为是利用多个域名指向同一网站，那么你的网站就会被封掉，罪名是 “利用重复的内容来干扰 Google 搜索结果的网站排名”。</p>
<h2 id="URL-和-URI"><a href="#URL-和-URI" class="headerlink" title="URL 和 URI"></a>URL 和 URI</h2><p>URI 叫做统一资源标志符，就是在某一规则下能把一个资源独一无二地标识出来。</p>
<p>URL 叫做统一资源定位符，是以描述资源的位置来唯一确定一个资源的。所以URL 是 URI 的子集。</p>
<h2 id="NAT：网络地址转换？"><a href="#NAT：网络地址转换？" class="headerlink" title="NAT：网络地址转换？"></a>NAT：网络地址转换？</h2><p>常用于私有地址与公有地址的转换，以解决 IP 地址匮乏的问题。</p>
<p>NAT 的基本工作原理是：当私有网主机和公共网主机通信的 IP 包经过 NAT 网关时，将 IP 包中的源 IP 或目的 IP 在私有 IP 和 NAT 的公共 IP 之间进行转换。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://490.github.io/Java虚拟机性能监控及调优/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="le">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Java虚拟机性能监控及调优/" itemprop="url">Java虚拟机性能监控及调优</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T10:51:16+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/Java虚拟机性能监控及调优/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/Java虚拟机性能监控及调优/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常用虚拟机性能监控工具"><a href="#常用虚拟机性能监控工具" class="headerlink" title="常用虚拟机性能监控工具"></a>常用虚拟机性能监控工具</h1><h2 id="JDK-命令行工具"><a href="#JDK-命令行工具" class="headerlink" title="JDK 命令行工具"></a>JDK 命令行工具</h2><p><img src="http://490.github.io/images/20190311_105149.png" alt="image"><br>其中的重中之重是 jstat 命令！而它最常用的参数就是 -gcutil，使用格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil [pid] [intervel] [count]</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<ul>
<li><code>S0</code>：堆上 Survivor space 0 区已使用空间的百分比</li>
<li><code>S1</code>：堆上 Survivor space 1 区已使用空间的百分比</li>
<li><code>E</code>：堆上 Eden 区已使用空间的百分比</li>
<li><code>O</code>：堆上 Old space 区已使用空间的百分比</li>
<li><code>P</code>：堆上 Perm space 区已使用空间的百分比</li>
<li><code>YGC</code>：从程序启动到采样时发生的 Minor GC 次数</li>
<li><code>YGCT</code>：从程序启动到采样时 Minor GC 所用的时间</li>
<li><code>FGC</code>：从程序启动到采样时发生的 Full GC 次数</li>
<li><code>FGCT</code>：从程序启动到采样时 Full GC 所用的时间</li>
<li><code>GCT</code>：从程序启动到采样时 GC 的总时间<h2 id="ps-命令-Linux"><a href="#ps-命令-Linux" class="headerlink" title="ps 命令 (Linux)"></a>ps 命令 (Linux)</h2>对于 <code>jps</code> 命令，其实没必要使用，一般使用 Linux 里的 <code>ps</code> 就够了，<code>ps</code> 为我们提供了当前进程状态的一次性的查看，它所提供的查看结果并不动态连续的，如果想对进程时间监控，应该用 <code>top</code> 工具。</li>
</ul>
<p><strong>Linux 上进程的 5 种状态</strong></p>
<ul>
<li>运行 [R, Runnable]：正在运行或者在运行队列中等待；</li>
<li>中断 [S, Sleep]：休眠中, 受阻, 在等待某个条件的形成或接受到信号；</li>
<li>不可中断 [D]：收到信号不唤醒和不可运行, 进程必须等待直到有中断发生；</li>
<li>僵死 [Z, zombie]：进程已终止, 但进程描述符存在, 直到父进程调用 wait4() 系统调用后释放；</li>
<li>停止 [T, Traced or stop]：进程收到 SIGSTOP, SIGSTP, SIGTIN, SIGTOU 信号后停止运行运行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ps -A # 列出所有进程信息（非详细信息）</span><br><span class="line">ps aux  # 列出所有进程的信息</span><br><span class="line">ps aux | grep zsh</span><br><span class="line"></span><br><span class="line">ps -ef # 显示所有进程信息，连同命令行</span><br><span class="line">ps -ef | grep zsh </span><br><span class="line"></span><br><span class="line">ps -u root # 显示指定用户信息</span><br><span class="line">ps -l  # 列出这次登录bash相关信息</span><br><span class="line"></span><br><span class="line">ps axjf  # 同时列出进程树状信息</span><br></pre></td></tr></table></figure>
<h1 id="JVM-常见参数设置"><a href="#JVM-常见参数设置" class="headerlink" title="JVM 常见参数设置"></a>JVM 常见参数设置</h1><h2 id="内存设置"><a href="#内存设置" class="headerlink" title="内存设置"></a>内存设置</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>-Xms</code>：初始堆大小，JVM 启动的时候，给定堆空间大小。</li>
<li><code>-Xmx</code>：最大堆大小，如果初始堆空间不足的时候，最大可以扩展到多少。</li>
<li><code>-Xmn</code>：设置年轻代大小。<code>整个堆大小 = 年轻代大小 + 年老代大小 + 持久代大小</code>。持久代一般固定大小为 64M，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun 官方推荐配置为整个堆的 3/8。</li>
<li><code>-Xss</code>： 设置每个线程的 Java 栈大小。JDK 5 后每个线程 Java 栈大小为 1M。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。</li>
<li><code>-XX:NewRatio=n</code>：设置年轻代和年老代的比值。如为 3，表示年轻代与年老代比值为 1:3。</li>
<li><code>-XX:MaxTenuringThreshold</code>：设置垃圾最大年龄。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，直接进入年老代。对于年老代比较多的应用（即 Minor GC 过后有大量对象存活的应用），可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在 Survivor 区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。</li>
</ul>
<h3 id="设置经验"><a href="#设置经验" class="headerlink" title="设置经验"></a>设置经验</h3><ul>
<li>开发过程的测试应用，要求物理内存大于 4G</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xmx3550m</span><br><span class="line">-Xms3550m </span><br><span class="line">-Xmn2g</span><br><span class="line">-Xss128k</span><br></pre></td></tr></table></figure>
<ul>
<li><p>高并发本地测试使用，大对象相对较多（如 IO 流）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-Xmx3550m</span><br><span class="line">-Xms3550m</span><br><span class="line">-Xss128k</span><br><span class="line">-XX:NewRatio=4</span><br><span class="line">-XX:SurvivorRatio=4</span><br><span class="line">-XX:MaxPermSize=160m</span><br><span class="line">-XX:MaxTenuringThreshold=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>环境： 16G 物理内存，高并发服务，重量级对象中等（线程池，连接池等），常用对象比例为 40%（即运行过程中产生的对象 40% 是生命周期较长的）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-Xmx10G</span><br><span class="line">-Xms10G</span><br><span class="line">-Xss1M</span><br><span class="line">-XX:NewRatio=3</span><br><span class="line">-XX:SurvivorRatio=4 </span><br><span class="line">-XX:MaxPermSize=2048m</span><br><span class="line">-XX:MaxTenuringThreshold=5</span><br></pre></td></tr></table></figure>
<h2 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h2><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul>
<li>收集器设置<ul>
<li><code>-XX:+UseSerialGC</code>：设置串行收集器，年轻带收集器。</li>
<li><code>-XX:+UseParallelGC</code>：设置并行收集器。</li>
<li><code>-XX:+UseParNewGC</code>：设置年轻代为并行收集。可与 CMS 收集同时使用。JDK 5.0 以上，JVM 会根据系统配置自行设置，所以无需再设置此值。</li>
<li><code>-XX:+UseParallelOldGC</code>：设置并行年老代收集器，JDK6.0 支持对年老代并行收集。</li>
<li><code>-XX:+UseConcMarkSweepGC</code>：设置年老代并发收集器，测试中配置这个以后，<code>-XX:NewRatio</code> 的配置失效，原因不明。所以，此时年轻代大小最好用 <code>-Xmn</code> 设置。</li>
<li><code>-XX:+UseG1GC</code>：设置 G1 收集器。</li>
</ul>
</li>
<li>并行收集器参数设置<ul>
<li><code>-XX:ParallelGCThreads=n</code>：设置并行收集器收集时最大线程数使用的 CPU 数。并行收集线程数。</li>
<li><code>-XX:MaxGCPauseMillis=n</code>：设置并行收集最大暂停时间，单位毫秒。</li>
<li><code>-XX:GCTimeRatio=n</code>：设置垃圾回收时间占程序运行时间的百分比。</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code>：设置此选项后，并行收集器会自动选择年轻代区大小和相应的 Survivor 区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</li>
<li><code>-XX:CMSFullGCsBeforeCompaction=n</code>：由于 CMS 不对内存空间进行压缩、整理，所以运行一段时间以后会产生”碎片”，使得运行效率降低。此值设置运行多少次 GC 以后对内存空间进行压缩、整理。</li>
<li><code>-XX:+UseCMSCompactAtFullCollection</code>：打开对年老代的压缩。可能会影响性能，但是可以消除碎片。<h1 id="虚拟机调优案例分析"><a href="#虚拟机调优案例分析" class="headerlink" title="虚拟机调优案例分析"></a>虚拟机调优案例分析</h1><h2 id="高性能硬件上的程序部署策略"><a href="#高性能硬件上的程序部署策略" class="headerlink" title="高性能硬件上的程序部署策略"></a>高性能硬件上的程序部署策略</h2><img src="http://490.github.io/images/20190311_105436.png" alt="image"><br><strong>补充：64 位虚拟机</strong><br>在 Java EE 方面，企业级应用经常需要使用超过 4GB 的内存，此时，32 位虚拟机将无法满足需求，可是 64 位虚拟机虽然可以设置更大的内存，却存在以下缺点：</li>
</ul>
</li>
</ul>
<ul>
<li><strong>内存问题：</strong> 由于指针膨胀和各种数据类型对齐补白的原因，运行于 64 位系统上的 Java 应用程序需要消耗更多的内存，通常要比 32 位系统额外增加 10% ~ 30% 的内存消耗。</li>
<li><strong>性能问题：</strong> 64 位虚拟机的运行速度在各个测试项中几乎全面落后于 32 位虚拟机，两者大概有 15% 左右的性能差距。</li>
</ul>
<h2 id="服务系统经常出现卡顿（Full-GC-时间太长）"><a href="#服务系统经常出现卡顿（Full-GC-时间太长）" class="headerlink" title="服务系统经常出现卡顿（Full GC 时间太长）"></a>服务系统经常出现卡顿（Full GC 时间太长）</h2><p>首先 <code>jstat -gcutil</code> 观察 GC 的耗时，<code>jstat -gccapacity</code> 检查内存用量（也可以加上 <code>-verbose:gc</code> 参数获取 GC 的详细日志），发现卡顿是由于 Full GC 时间太长导致的，然后 <code>jinfo -v pid</code>，查看虚拟机参数设置，发现 <code>-XX:NewRatio=9</code>，这就是原因：</p>
<ul>
<li>新生代太小，对象提前进入老年代，触发 Full GC</li>
<li>老年代较大，一次 Full GC 时间较长</li>
</ul>
<p>可以调小 NewRatio 的值，尽肯能让比较少的对象进入老年代。</p>
<h2 id="除了-Java-堆和永久代之外，会占用较多内存的区域"><a href="#除了-Java-堆和永久代之外，会占用较多内存的区域" class="headerlink" title="除了 Java 堆和永久代之外，会占用较多内存的区域"></a>除了 Java 堆和永久代之外，会占用较多内存的区域</h2><table>
<thead>
<tr>
<th>区域</th>
<th>大小调整 / 说明</th>
<th>内存不足时抛出的异常</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接内存</td>
<td><code>-XX:MaxDirectMemorySize</code></td>
<td>OutOfMemoryError: Direct buffer memory</td>
</tr>
<tr>
<td>线程堆栈</td>
<td><code>-Xss</code></td>
<td>StackOverflowError 或 OutOfMemoryError: unable to create new native thread</td>
</tr>
<tr>
<td>Socket 缓存区</td>
<td>每个 Socket 连接都有 Receive(37KB) 和 Send(25KB) 两个缓存区</td>
<td>IOException: Too many open files</td>
</tr>
<tr>
<td>JNI 代码</td>
<td>如果代码中使用 JNI 调用本地库，那本地库使用的内存也不在堆中</td>
<td></td>
</tr>
<tr>
<td>虚拟机和 GC</td>
<td>虚拟机、GC 代码执行要消耗一定内存</td>
</tr>
</tbody>
</table>
<h2 id="从-GC-调优角度解决新生代存活大量对象问题（Minor-GC-时间太长）"><a href="#从-GC-调优角度解决新生代存活大量对象问题（Minor-GC-时间太长）" class="headerlink" title="从 GC 调优角度解决新生代存活大量对象问题（Minor GC 时间太长）"></a>从 GC 调优角度解决新生代存活大量对象问题（Minor GC 时间太长）</h2><ul>
<li>将 Survivor 空间去除，让新生代中存活的对象在第一次 Minor GC 后立刻进入老年代，等到 Full GC 时再清理。</li>
<li>参数调整方法：<ul>
<li><code>-XX:SurvivorRatio=65536</code></li>
<li><code>-XX:MaxTenuringThreshold=0</code></li>
<li><code>-XX:AlwaysTenure</code></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://490.github.io/Java的类加载器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="le">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Java的类加载器/" itemprop="url">Java的类加载器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-10T23:17:20+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/Java的类加载器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/Java的类加载器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  861
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>JAVA类装载方式，有两种:1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中。 2.显式装载， 通过class.forname()等方法，显式加载需要的类<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/Java的类加载器/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://490.github.io/Servlet的生命周期与工作原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="le">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Servlet的生命周期与工作原理/" itemprop="url">Servlet的生命周期与工作原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-10T23:16:11+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/Servlet的生命周期与工作原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/Servlet的生命周期与工作原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  196
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>Servlet运行在Servlet容器中，其生命周期由容器来管理。Servlet的生命周期通过javax.servlet.Servlet接口中的init()、service()和destroy()方法来表示,Servlet的生命周期包含了下面4个阶段：</p>
<ol>
<li>加载和实例化</li>
<li>初始化</li>
<li>请求处理</li>
<li>服务终止
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/Servlet的生命周期与工作原理/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </li></ol></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://490.github.io/Java的异常体系/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="le">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Java的异常体系/" itemprop="url">Java的异常体系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-10T23:15:53+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/Java的异常体系/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/Java的异常体系/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  304
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>受检查的(checked)异常和不受检查的(unchecked)异常<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/Java的异常体系/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://490.github.io/Java的IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="le">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Java的IO/" itemprop="url">Java的IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-10T23:15:41+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/Java的IO/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/Java的IO/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  0
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://490.github.io/Java容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="le">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Java容器/" itemprop="url">Java容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-10T23:15:33+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/Java容器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/Java容器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  0
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://490.github.io/Java反射、泛型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="le">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Java反射、泛型/" itemprop="url">Java反射、泛型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-10T23:15:26+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/Java反射、泛型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/Java反射、泛型/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  930
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a><a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">泛型</a></h1><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/Java反射、泛型/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://490.github.io/Java的深拷贝与浅拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="le">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Java的深拷贝与浅拷贝/" itemprop="url">Java的深拷贝与浅拷贝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-10T23:14:58+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/Java的深拷贝与浅拷贝/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/Java的深拷贝与浅拷贝/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  135
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/xiaxia__/article/details/41652057" target="_blank" rel="noopener">Java深拷贝浅拷贝</a><br>将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式是浅拷贝，第三种是深拷贝。<br>浅：属性不一样，对象（方法）什么的一样<br>深：都不一样<br>new Integer(123) 与 Integer.valueOf(123) 的区别在于，new Integer(123) 每次都会新建一个对象，而 Integer.valueOf(123) 可能会使用缓存对象，因此多次使用 Integer.valueOf(123) 会取得同一个对象的引用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://490.github.io/SpringBoot实现基于Token的web后台认证机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="le">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/SpringBoot实现基于Token的web后台认证机制/" itemprop="url">SpringBoot实现基于Token的web后台认证机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-10T15:38:48+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/SpringBoot实现基于Token的web后台认证机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/SpringBoot实现基于Token的web后台认证机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="几种常用的认证机制"><a href="#几种常用的认证机制" class="headerlink" title="几种常用的认证机制"></a>几种常用的认证机制</h1><p>HTTP Basic Auth、OAuth、Cookie Auth、Token Auth</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/SpringBoot实现基于Token的web后台认证机制/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">le</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/490" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/2961822005" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">le</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">46.7k</span>
  
</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    





  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'Yi80CT04XNkVSJTMAPm5FtWc-gzGzoHsz',
        appKey: 'j3zcBrBI4kxBuazJBe3Gra3B',
        placeholder: '^_^',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":80,"height":160},"mobile":{"show":true}});</script></body>
</html>
