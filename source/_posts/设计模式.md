---
title: 设计模式---基于Java详解(全)
date: 2019-03-12 23:37:43
tags: 设计模式
---
- **创建型模式：** 对象实例化的模式，创建型模式用于解耦对象的实例化过程。
  - [**单例模式**](#单例模式)：某个类只能有一个实例，提供一个全局的访问点。
  - [简单工厂模式](#简单工厂)：一个工厂类根据传入的参量决定创建出那一种产品类的实例。
  - [**工厂方法模式**](#工厂方法)：定义一个创建对象的接口，让子类决定实例化那个类。
  - [**抽象工厂模式**](#抽象工厂)：创建相关或依赖对象的家族，而无需明确指定具体类。
  - [建造者模式](#建造者模式)：封装一个复杂对象的构建过程，并可以按步骤构造。
  - [原型模式](#原型模式)：通过复制现有的实例来创建新的实例。
- **结构型模式：** 把类或对象结合在一起形成一个更大的结构。
  - [**适配器模式**](#适配器模式)：将一个类的方法接口转换成客户希望的另外一个接口。
  - [**外观模式**](#外观模式)：对外提供一个统一的方法，来访问子系统中的一群接口。
  - [组合模式](#组合模式)：将对象组合成树形结构以表示“”部分-整体“”的层次结构。
  - [**装饰模式**](#装饰模式)：动态的给对象添加新的功能。
  - [**代理模式**](#代理模式)：为其他对象提供一个代理以便控制这个对象的访问。
  - [享元模式](#享元模式)：通过共享技术来有效的支持大量细粒度的对象。
  - [桥接模式](#桥接模式)：将抽象部分和它的实现部分分离，使它们都可以独立的变化。
- **行为型模式：** 类和对象如何交互，及划分责任和算法。
  - [模板模式](#模板模式)：定义一个算法结构，而将一些步骤延迟到子类实现。
  - [迭代器模式](#迭代器模式)：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。
  - [**策略模式**](#策略模式)：定义一系列算法，把他们封装起来，并且使它们可以相互替换。
  - [状态模式](#状态模式)：允许一个对象在其对象内部状态改变时改变它的行为。
  - [**观察者模式**](#观察者模式)：对象间的一对多的依赖关系。
  - [解释器模式](#解释器模式)：给定一个语言，定义它的文法的一种表示，并定义一个解释器。
  - [备忘录模式](#备忘录模式)：在不破坏封装的前提下，保持对象的内部状态。
  - [中介者模式](#中介者模式)：用一个中介对象来封装一系列的对象交互。
  - [命令模式](#命令模式)：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。
  - [访问者模式](#访问者模式)：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。
  - [责任链模式](#责任链模式)：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。

<!--more-->

![image](http://490.github.io/images/20190312_233919.png)

# 创建者模式

## 单例模式

单例模式是一种对象创建型模式，使用单例模式，可以保证为一个类只生成唯一的实例对象。也就是说，在整个程序空间中，该类只存在一个实例对象。GoF对单例模式的定义是：保证一个类、只有一个实例存在，同时提供能对该实例加以访问的全局访问方法。

应用场景：
*   在多个线程之间，比如servlet环境，共享同一个资源或者操作同一个对象
*   在整个程序空间使用全局变量，共享资源
*   大规模系统中，为了性能的考虑，需要节省对象的创建时间等等。

**优点**

1. 于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级的对象而言，是很重要的.
2. 不需要频繁创建对象，GC压力也减轻了，而在GC中会有STW(stop the world)，从这一方面也节约了GC的时间 

**缺点**

简单的单例模式设计开发都比较简单，但是复杂的单例模式需要考虑线程安全等并发问题，引入了部分复杂度。

设计单例模式的时候一般需要考虑几种因素:线程安全；延迟加载 ；代码安全:如防止序列化攻击，防止反射攻击(防止反射进行私有方法调用) ；性能因素

### 饿汉式 static final field

```java
public class Singleton
{
    private static final Singleton instance = new Singleton(); // 类加载时就初始化
    private Singleton(){}
    public static Singleton getInstance()
    {
        return instance;
    }
}
```

Singleton类被加载的时候就会被初始化，java虚拟机规范虽然没有强制性约束在什么时候开始类加载过程，但是对于类的初始化，虚拟机规范则严格规定了有且只有四种情况必须立即对类进行初始化，遇到new、getStatic、putStatic或invokeStatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。 生成这4条指令最常见的java代码场景是：
- 使用new关键字实例化对象
- 读取一个类的静态字段（被final修饰、已在编译期把结果放在常量池的静态字段除外）
- 设置一个类的静态字段（被final修饰、已在编译期把结果放在常量池的静态字段除外）
- 调用一个类的静态方法

[这个知识点详见《Java虚拟机的类加载机制》](java虚拟机的执行机制#虚拟机的类加载机制)



### 懒汉式（线程不安全）

```java
public class Singleton 
{
    private static Singleton instance;
    private Singleton (){}
    public static Singleton getInstance() 
    {
        if (instance == null) //只有为空才new，很懒，饿汉一上来就new不管怎样。
        {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### 懒汉式（线程安全）

```java
public static synchronized Singleton getInstance() 
{
    if (instance == null) 
    {
        instance = new Singleton();
    }
    return instance;
}
```

### 双重检验锁 double check lock

```java
public class Singleton 
{
    private volatile static Singleton instance; // 声明成 volatile
    private Singleton (){}
    public static Singleton getSingleton() 
    {
        if (instance == null) 
        {
            synchronized (Singleton.class) 
            {
                if (instance == null) 
                {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

延迟初始化。
synchronized同步块里面能够保证只创建一个对象。但是通过在synchronized的外面增加一层判断，就可以在对象一经创建以后，不再进入synchronized同步块。这种方案不仅减小了锁的粒度，保证了线程安全，性能方面也得到了大幅提升。
volatile在这里是用来防止指令重排序的。

[volatile知识点详见《Java多线程与并发》](java多线程与并发#volatile关键字)


### 静态内部类 static nested class

```java
public class Singleton 
{  
    private static class InnerClass//这个对象的初始化锁，看哪个线程能拿到
    {  
        private static final Singleton INSTANCE = new Singleton();  
    }
    private Singleton (){}
    public static final Singleton getInstance() 
    {  
        return InnerClass.INSTANCE; 
    }
}
```

基于类初始化的延迟加载解决方案。（既保证了线程的安全，有能够延迟加载，也就是在第一次使用的时候加载）一个线程初始化时，另一个线程会被锁到Class对象的初始化那里，无法进入到
1. 分配对象的内存空间
2. 设置instance指向内存空间
3. 初始化对象
这些步骤里。
这种写法仍然使用 JVM 本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。
     

### 枚举 Enum

```java
public enum Singleton 
{
    INSTANCE;
    private String objName;
    public String getObjName() 
    {
        return objName;
    }
    public void setObjName(String objName) 
    {
        this.objName = objName;
    }
    public static void main(String[] args) 
    {
        // 单例测试
        Singleton firstSingleton = Singleton.INSTANCE;
        firstSingleton.setObjName("firstName");
        System.out.println(firstSingleton.getObjName());
        Singleton secondSingleton = Singleton.INSTANCE;
        secondSingleton.setObjName("secondName");
        System.out.println(firstSingleton.getObjName());
        System.out.println(secondSingleton.getObjName());
        // 反射获取实例测试
        try {
            Singleton[] enumConstants = Singleton.class.getEnumConstants();
            for (Singleton enumConstant : enumConstants) {
                System.out.println(enumConstant.getObjName());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

enum没有无参构造器，所以无法用反射方法破坏单例。

 [深度分析Java的枚举类型—-枚举的线程安全性及序列化问题](https://www.hollischuang.com/archives/197)
 
```java
public enum t {
    SPRING,SUMMER,AUTUMN,WINTER;
}

反编译

public final class T extends Enum
{
    private T(String s, int i)
    {
        super(s, i);
    }
    public static T[] values()
    {
        T at[];
        int i;
        T at1[];
        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);
        return at1;
    }

    public static T valueOf(String s)
    {
        return (T)Enum.valueOf(demo/T, s);
    }

    public static final T SPRING;
    public static final T SUMMER;
    public static final T AUTUMN;
    public static final T WINTER;
    private static final T ENUM$VALUES[];
    static
    {
        SPRING = new T("SPRING", 0);
        SUMMER = new T("SUMMER", 1);
        AUTUMN = new T("AUTUMN", 2);
        WINTER = new T("WINTER", 3);
        ENUM$VALUES = (new T[] {
            SPRING, SUMMER, AUTUMN, WINTER
        });
    }
}
```



### 序列化破坏单例模式原理解析及解决方案

反序列化的时候是用反射创建的，所以不一样

解决方法，在类里加个方法， readResolve这个名字是ObjectStream规定好的

```java
private Object readResolve(){
    return hungrySingleton;
}
```

### 反射攻击解决方案及原理分析

通过反射来修改获取、修改构造函数，然后获取方法

```java
Class objectClass = HungrySingleton.class;
Constructor constructor = objectClass.getDeclaredConstructor(HungrySingleton.class);
constructor.setAccessible(true);
HungrySingleton instance = HungrySingleton.getInstance();
HungrySingleton newInstance = (HungrySingleton) constructor.newInstance();//调用无参构造方法，对象实例化
```

```java
在类加载的时候就初始化好对象的，两种

private HungrySingleton()
{
      if(hungrySingleton != null){
          throw new RuntimeException("单例构造器禁止反射调用");
      }
}

private StaticInnerClassSingleton()
{
        if(InnerClass.staticInnerClassSingleton != null){
            throw new RuntimeException("单例构造器禁止反射调用");
        }
}
```

对于懒汉，这种后初始化对象的，如果反射先进来，就会有两个对象，在构造器里加判断也没有；反射后进来这种方法还有用。



### 容器单例

```java
public class ContainerSingleton 
{
    private ContainerSingleton(){}
    private static Map<String,Object> singletonMap = new HashMap<String,Object>();
    public static void putInstance(String key,Object instance)
    {
        if(StringUtils.isNotBlank(key) && instance != null)
        {
            if(!singletonMap.containsKey(key))
            {
                singletonMap.put(key,instance);
            }
        }
    }
    public static Object getInstance(String key)
    {
        return singletonMap.get(key);
    }
}
```

这种方式实现的单例是线程不安全的。如果需要线程安全的可以使用HashTable但是HashTable每次存取都会加上同步锁，性能损耗比较严重。或者使用ConcurrentHashMap。




### ThreadLocal线程单例

这个单例严格意义上讲并不完全算是单例，它只能算在单个线程中的单例，也就是在同一个线程中的它是单例的。



![image](http://490.github.io/images/20190316_130326.png)


## 工厂方法模式

简单工厂

简单工厂并不是一个设计模式，而是一种编程习惯。

![image](http://490.github.io/images/20190314_105449.png)

logger、calendar等类是这个模式


![image](http://490.github.io/images/20190314_104642.png)

![image](http://490.github.io/images/20190314_105532.png)

作为抽象工厂模式的孪生兄弟，工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。

工厂方法模式非常符合“开闭原则”，当需要增加一个新的产品时，我们只需要增加一个具体的产品类和与之对应的具体工厂即可，无须修改原有系统。同时在工厂方法模式中用户只需要知道生产产品的具体工厂即可，无须关系产品的创建过程，甚至连具体的产品类名称都不需要知道。虽然他很好的符合了“开闭原则”，但是由于每新增一个新产品时就需要增加两个类，这样势必会导致系统的复杂度增加。

Collection的Iterator方法是工厂方法模式。

## 抽象工厂模式

![抽象工厂.png](./pic/抽象工厂.png)

所谓抽象工厂模式就是提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。他允许客户端使用抽象的接口来创建一组相关的产品，而不需要关系实际产出的具体产品是什么。这样一来，客户就可以从具体的产品中被解耦。

它的优点是隔离了具体类的生成，使得客户端不需要知道什么被创建了，而缺点就在于新增新的行为会比较麻烦，因为当添加一个新的产品对象时，需要更加需要更改接口及其下所有子类。



## 建造者模式

![建造者模式.png](./pic/建造者模式.png)

对于建造者模式而已，它主要是将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。适用于那些产品对象的内部结构比较复杂。

建造者模式将复杂产品的构建过程封装分解在不同的方法中，使得创建过程非常清晰，能够让我们更加精确的控制复杂产品对象的创建过程，同时它隔离了复杂产品对象的创建和使用，使得相同的创建过程能够创建不同的产品。但是如果某个产品的内部结构过于复杂，将会导致整个系统变得非常庞大，不利于控制，同时若几个产品之间存在较大的差异，则不适用建造者模式，毕竟这个世界上存在相同点大的两个产品并不是很多，所以它的使用范围有限。



## 原型模式

![原型模式.png](./pic/原型模式.png)

# 结构型模式

## 适配器模式

![image](http://490.github.io/images/20190316_181226.png)

在我们的应用程序中我们可能需要将两个不同接口的类来进行通信，在不修改这两个的前提下我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。所谓适配器模式就是将一个类的接口，转换成客户期望的另一个接口。它可以让原本两个不兼容的接口能够无缝完成对接。

作为中间件的适配器将目标类和适配者解耦，增加了类的透明性和可复用性。


## 外观模式

![外观模式.png](./pic/外观模式.png)




## 组合模式

![组合模式.png](./pic/组合模式.png)



## 装饰模式

![装饰模式.png](./pic/装饰模式.png)



## 代理模式

为另一个对象提供一个替身或占位符以控制对这个对象的访问。

![代理模式.png](./pic/代理模式.png)

- Proxy 中有一个 RealSubject 对象，我们拿不到 RealSubject 对象，只能拿到 Proxy 对象；
- Proxy 和 RealSubject 都实现了 Subject 接口，它们有相同的方法；
- 我们通过 Proxy 对象调用 RealSubject 对象的方法，不过在调用前，Proxy 会先检查一下这个调用合不合理，不合理它就不调用 RealSubject 对象的方法。



## 享元模式

![享元模式.png](./pic/享元模式.png)



## 桥接模式

![桥接模式.png](./pic/桥接模式.png)


# 行为型模式

## 模板模式

![模板模式.png](./pic/模板模式.png)



## 迭代器模式

![迭代器模式.png](./pic/迭代器模式.png)




## 策略模式

![策略模式.png](./pic/策略模式.png)



## 状态模式

![状态模式.png](./pic/状态模式.png)



## 观察者模式

![观察者模式.png](./pic/观察者模式.png)



## 解释器模式

![解释器模式.png](./pic/解释器模式.png)




## 备忘录模式

![备忘录模式.png](./pic/备忘录模式.png)



## 中介者模式

![中介者模式.png](./pic/中介者模式.png)



## 命令模式

![命令模式.png](./pic/命令模式.png)



## 访问者模式

![访问者模式.png](./pic/访问者模式.png)



## 责任链模式

![责任链模式.png](./pic/责任链模式.png)







**参考：**

- [图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/)
- [JAVA设计模式总结之23种设计模式](https://www.cnblogs.com/pony1223/p/7608955.html)
- [如何正确地写出单例模式](http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/)
