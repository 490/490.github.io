---
title: 彻底理解KMP
date: 2019-03-30 19:09:44
tags: 算法
---
 转自[从头到尾彻底理解KMP（2014年8月22日版）](https://blog.csdn.net/v_july_v/article/details/7041827#comments)

<!--more-->

# 暴力匹配算法
假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？

如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：

如果当前字符匹配成功（即`S[i] == P[j]`），则`i++,j++`，继续匹配下一个字符；
如果失配（即`S[i]! = P[j]`），令`i = i - (j - 1)，j = 0`。相当于每次匹配失败时，i 回溯，j 被置为0。
    理清楚了暴力匹配算法的流程及内在的逻辑，咱们可以写出暴力匹配的代码，如下：

```c
int ViolentMatch(char* s, char* p)
{
	int sLen = strlen(s);
	int pLen = strlen(p);
 
	int i = 0;
	int j = 0;
	while (i < sLen && j < pLen)
	{
		if (s[i] == p[j])
		{
			//①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++    
			i++;
			j++;
		}
		else
		{
			//②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0    
			i = i - j + 1;
			j = 0;
		}
	}
	//匹配成功，返回模式串p在文本串s中的位置，否则返回-1
	if (j == pLen)
		return i - j;
	else
		return -1;
}
```

# KMP算法

##  定义

Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。

下面先直接给出KMP的算法流程：

假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置
- 如果`j = -1`，或者当前字符匹配成功（即`S[i] == P[j]`），都令`i++，j++`，继续匹配下一个字符；
- 如果`j != -1`，且当前字符匹配失败（即`S[i] != P[j]`），则令 i 不变，`j = next[j]`。此举意味着失配时，模式串P相对于文本串S向右移动了`j - next [j]` 位。
换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文详细阐述），即移动的实际位数为：`j - next[j]`，且此值大于等于1。

很快，你也会意识到next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果`next [j] = k`，代表j 之前的字符串中有最大长度为k 的相同前缀后缀。

此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若`next [j] = k` 且 `k > 0`，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。

```c
int KmpSearch(char* s, char* p)
{
	int i = 0;
	int j = 0;
	int sLen = strlen(s);
	int pLen = strlen(p);
	while (i < sLen && j < pLen)
	{
		//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    
		if (j == -1 || s[i] == p[j])
		{
			i++;
			j++;
		}
		else
		{
			//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    
			//next[j]即为j所对应的next值      
			j = next[j];
		}
	}
	if (j == pLen)
		return i - j;
	else
		return -1;
}
```

当S[10]跟P[6]匹配失败时，KMP不是跟暴力匹配那样简单的把模式串右移一位，而是执行第②条指令：“如果`j != -1`，且当前字符匹配失败（即`S[i] != P[j]`），则令 i 不变，`j = next[j]`”，即j 从6变到2（后面我们将求得P[6]，即字符D对应的next 值为2），所以相当于模式串向右移动的位数为`j - next[j]（j - next[j] = 6-2 = 4）`。

![image](http://490.github.io/images/20190330_192726.png)

向右移动4位后，S[10]跟P[2]继续匹配。为什么要向右移动4位呢，因为移动4位后，模式串中又有个“AB”可以继续跟S[8]S[9]对应着，从而不用让i 回溯。相当于在除去字符`D`的模式串子串中寻找相同的前缀和后缀，然后根据前缀后缀求出next 数组，最后基于next 数组进行匹配。

## 步骤

1. **寻找前缀后缀最长公共元素长度**
对于`P = p0 p1 ...pj-1 pj`，寻找模式串P中长度最大且相等的前缀和后缀。如果存在`p0 p1 ...pk-1 pk = pj- k pj-k+1...pj-1 pj`，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。举个例子，如果给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示：

![image](http://490.github.io/images/20190330_193038.png)

比如对于字符串aba来说，它有长度为1的相同前缀后缀a；而对于字符串abab来说，它有长度为2的相同前缀后缀ab（相同前缀后缀的长度为`k + 1，k + 1 = 2`）。

2. **求next数组**
next 数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为-1，如下表格所示：

![image](http://490.github.io/images/20190330_193119.png)

比如对于`aba`来说，第3个字符a之前的字符串ab中有长度为0的相同前缀后缀，所以第3个字符a对应的next值为0；而对于abab来说，第4个字符b之前的字符串aba中有长度为1的相同前缀后缀a，所以第4个字符b对应的next值为1（相同前缀后缀的长度为k，k = 1）。

3. **根据next数组进行匹配**
匹配失配，`j = next [j]`，模式串向右移动的位数为：`j - next[j]`。换言之，当模式串的后缀`pj-k pj-k+1, ..., pj-1` 跟文本串`si-k si-k+1, ..., si-1`匹配成功，但pj 跟si匹配失败时，因为`next[j] = k`，相当于在不包含pj的模式串中有最大长度为k 的相同前缀后缀，即`p0 p1 ...pk-1 = pj-k pj-k+1...pj-1`，故令`j = next[j]`，从而让模式串右移`j - next[j]` 位，使得模式串的前缀`p0 p1, ..., pk-1`对应着文本串 `si-k si-k+1, ..., si-1`，而后让pk 跟si 继续匹配。如下图所示：

![image](http://490.github.io/images/20190330_193214.png)

 综上，KMP的next 数组相当于告诉我们：当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置。如模式串中在j 处的字符跟文本串在i 处的字符匹配失配时，下一步用next [j] 处的字符继续跟文本串i 处的字符匹配，相当于模式串向右移动`j - next[j]` 位。

  接下来，分别具体解释上述3个步骤。

## 解释

### 寻找最长前缀后缀

  如果给定的模式串是：`ABCDABD`，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示：

![image](http://490.github.io/images/20190330_193356.png)

原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（简称《最大长度表》）：


![image](http://490.github.io/images/20190330_193419.png)

### 基于《最大长度表》匹配

 因为模式串中首尾可能会有重复的字符，故可得出下述结论：

> 失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值
    
  下面，咱们就结合之前的《最大长度表》和上述结论，进行字符串的匹配。如果给定文本串`BBC ABCDAB ABCDABCDABDE`，和模式串`ABCDABD`，现在要拿模式串去跟文本串匹配，如下图所示：

![image](http://490.github.io/images/20190330_193523.png)

1. 因为模式串中的字符A跟文本串中的字符B、B、C、空格一开始就不匹配，所以不必考虑结论，直接将模式串不断的右移一位即可，直到模式串中的字符A跟文本串的第5个字符A匹配成功：

![image](http://490.github.io/images/20190330_193537.png)

2. 继续往后匹配，当模式串最后一个字符D跟文本串匹配时失配，显而易见，模式串需要向右移动。但向右移动多少位呢？因为此时已经匹配的字符数为6个（ABCDAB），然后根据《最大长度表》可得失配字符D的上一位字符B对应的长度值为2，所以根据之前的结论，可知需要向右移动6 - 2 = 4 位。

3. 模式串向右移动4位后，发现C处再度失配，因为此时已经匹配了2个字符（AB），且上一位字符B对应的最大长度值为0，所以向右移动：2 - 0 =2 位。

![image](http://490.github.io/images/20190330_193619.png)

4. A与空格失配，向右移动1 位。
5. 继续比较，发现D与C 失配，故向右移动的位数为：已匹配的字符数6减去上一位字符B对应的最大长度2，即向右移动6 - 2 = 4 位。

![image](http://490.github.io/images/20190330_193657.png)

6. 经历第5步后，发现匹配成功，过程结束。

![image](http://490.github.io/images/20190330_193710.png)


 通过上述匹配过程可以看出，问题的关键就是寻找模式串中最大长度的相同前缀和后缀，找到了模式串中每个字符之前的前缀和后缀公共部分的最大长度后，便可基于此匹配。而这个最大长度便正是next 数组要表达的含义。

### 根据《最大长度表》求next 数组

由上文，我们已经知道，字符串“ABCDABD”各个前缀后缀的最大公共元素长度分别为：

![image](http://490.github.io/images/20190330_193736.png)

而且，根据这个表可以得出下述结论

> 失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值
    
上文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。

 给定字符串“ABCDABD”，可求得它的next 数组如下：

![image](http://490.github.io/images/20190330_193757.png)

把next 数组跟之前求得的最大长度表对比后，不难发现，next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1。意识到了这一点，你会惊呼原来next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1（当然，你也可以直接计算某个字符对应的next值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀）。

 换言之，对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别如下：

![image](http://490.github.io/images/20190330_193811.png)

根据最大长度表求出了next 数组后，从而有

> 失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值

而后，你会发现，无论是基于《最大长度表》的匹配，还是基于next 数组的匹配，两者得出来的向右移动的位数是一样的。为什么呢？因为：

- 根据《最大长度表》，失配时，模式串向右移动的位数 = 已经匹配的字符数 - 失配字符的上一位字符的最大长度值
- 而根据《next 数组》，失配时，模式串向右移动的位数 = 失配字符的位置 - 失配字符对应的next 值
 - 其中，从0开始计数时，失配字符的位置 = 已经匹配的字符数（失配字符不计数），而失配字符对应的next 值 = 失配字符的上一位字符的最大长度值，两相比较，结果必然完全一致。

所以，你可以把《最大长度表》看做是next 数组的雏形，甚至就把它当做next 数组也是可以的，区别不过是怎么用的问题。

### 通过代码递推计算next 数组

接下来，咱们来写代码求下next 数组。基于之前的理解，可知计算next 数组的方法可以采用递推：

1. 如果对于值k，已有`p0 p1, ..., pk-1 = pj-k pj-k+1, ..., pj-1`，相当于`next[j] = k`。
此意味着什么呢？究其本质，`next[j] = k` 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀。有了这个next 数组，在KMP匹配中，当模式串中j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动`j - next[j]` 位。

举个例子，如下图，根据模式串“ABCDABD”的next 数组可知失配位置的字符D对应的next 值为2，代表字符D前有长度为2的相同前缀和后缀（这个相同的前缀后缀即为“AB”），失配后，模式串需要向右移动`j - next [j] = 6 - 2 =4`位。

![image](http://490.github.io/images/20190330_193931.png)

向右移动4位后，模式串中的字符C继续跟文本串匹配。

![image](http://490.github.io/images/20190330_193944.png)

2. 下面的问题是：已知next [0, ..., j]，如何求出next [j + 1]呢？
    对于P的前j+1个序列字符：

- 若p`[k] == p[j]`，则`next[j + 1 ] = next [j] + 1 = k + 1`；
- 若`p[k ] ≠ p[j]`，如果此时`p[ next[k] ] == p[j ]`，则`next[ j + 1 ] =  next[k] + 1`，否则继续递归前缀索引`k = next[k]`，而后重复此过程。 相当于在字符p[j+1]之前不存在长度为k+1的前缀"`p0 p1, …, pk-1 pk`"跟后缀“`pj-k pj-k+1, …, pj-1 pj`"相等，那么是否可能存在另一个值`t+1 < k+1`，使得长度更小的前缀 `p0 p1, …, pt-1 pt` 等于长度更小的后缀 “`pj-t pj-t+1, …, pj-1 pj`” 呢？如果存在，那么这个t+1 便是next[ j+1]的值，此相当于利用已经求得的next 数组`（next [0, ..., k, ..., j]）`进行P串前缀跟P串后缀的匹配。
   一般的文章或教材可能就此一笔带过，但大部分的初学者可能还是不能很好的理解上述求解next 数组的原理，故接下来，我再来着重说明下。

如下图所示，假定给定模式串ABCDABCE，且已知`next [j] = k`（相当于`“p0 pk-1” = “pj-k pj-1” = AB`，可以看出k为2），现要求next [j + 1]等于多少？因为`pk = pj = C`，所以`next[j + 1] = next[j] + 1 = k + 1`（可以看出`next[j + 1] = 3`）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。

![image](http://490.github.io/images/20190330_194304.png)

   但如果pk != pj 呢？说明`p0 pk-1 pk ≠ pj-k pj-1 pj`。换言之，当`pk != pj`后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：`next[j + 1] = next[j] + 1` 。所以，咱们只能去寻找长度更短一点的相同前缀后缀。

![image](http://490.github.io/images/20190330_194338.png)


结合上图来讲，若能在前缀`p0 pk-1 pk` 中不断的递归前缀索引`k = next [k]`，找到一个字符pk’ 也为D，代表`pk’ = pj`，且满足`p0 pk'-1 pk' = pj-k' pj-1 pj`，则最大相同的前缀后缀长度为`k' + 1`，从而`next [j + 1] = k’ + 1 = next [k' ] + 1`。否则前缀中没有D，则代表没有相同的前缀后缀，`next [j + 1] = 0`。

那为何递归前缀索引k = next[k]，就能找到长度更短的相同前缀后缀呢？这又归根到next数组的含义。我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则需要寻找长度更短的相同前缀后缀，即下一步用p[ next[ next[k] ] ]去跟pj匹配。此过程相当于模式串的自我匹配，所以不断的递归k = next[k]，直到要么找到长度更短的相同前缀后缀，要么没有长度更短的相同前缀后缀。如下图所示：

![image](http://490.github.io/images/20190330_194539.png)


> 引用下一读者wudehua55555于本文评论下留言，以辅助大家从另一个角度理解：“ 一直以为博主在用递归求next数组时没讲清楚，为何要用k = next[k],仔细看了这个红黄蓝分区图才突然恍然大悟，就是找到p[k]对应的next[k]，根据对称性，只需再判断p[next[k]]与p[j]是否相等即可，于是令k = next[k],这里恰好就使用了递归的思路。其实我觉得不要一开始就陷入递归的方法中，换一种思路，直接从考虑对称性入手，可直接得出k = next[k]，而这正好是递归罢了。以上是一些个人看法，非常感谢博主提供的解析，非计算机的学生也能看懂，虽然从昨晚9点看到了现在。高兴。”

所以，因最终在前缀ABC中没有找到D，故E的next 值为0：

模式串的后缀：AB**DE**
模式串的前缀：AB**C**
前缀右移两位：**A**BC
    读到此，有的读者可能又有疑问了，那能否举一个能在前缀中找到字符D的例子呢？OK，咱们便来看一个能在前缀中找到字符D的例子，如下图所示：

![image](http://490.github.io/images/20190330_194830.png)

  给定模式串DABCDABDE，我们很顺利的求得字符D之前的“DABCDAB”的各个子串的最长相同前缀后缀的长度分别为0 0 0 0 1 2 3，但当遍历到字符D，要求包括D在内的“DABCDABD”最长相同前缀后缀时，我们发现pj处的字符D跟pk处的字符C不一样，换言之，前缀DABC的最后一个字符C 跟后缀DABD的最后一个字符D不相同，所以不存在长度为4的相同前缀后缀。

怎么办呢？既然没有长度为4的相同前缀后缀，咱们可以寻找长度短点的相同前缀后缀，最终，因在p0处发现也有个字符D，p0 = pj，所以p[j]对应的长度值为1，相当于E对应的next 值为1（即字符E之前的字符串“DABCDABD”中有长度为1的相同前缀和后缀）。

 综上，可以通过递推求得next 数组，代码如下所示：

```c
void GetNext(char* p,int next[])
{
	int pLen = strlen(p);
	next[0] = -1;
	int k = -1;
	int j = 0;
	while (j < pLen - 1)
	{
		//p[k]表示前缀，p[j]表示后缀
		if (k == -1 || p[j] == p[k]) 
		{
			++k;
			++j;
			next[j] = k;
		}
		else 
		{
			k = next[k];
		}
	}
}
```

用代码重新计算下“ABCDABD”的next 数组，以验证之前通过“最长相同前缀后缀长度值右移一位，然后初值赋为-1”得到的next 数组是否正确，计算结果如下表格所示：

![image](http://490.github.io/images/20190330_194916.png)

从上述表格可以看出，无论是之前通过“最长相同前缀后缀长度值右移一位，然后初值赋为-1”得到的next 数组，还是之后通过代码递推计算求得的next 数组，结果是完全一致的。

### 基于《next 数组》匹配

下面，我们来基于next 数组进行匹配。

![image](http://490.github.io/images/20190330_194944.png)

 还是给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示：

![image](http://490.github.io/images/20190330_194953.png)

 在正式匹配之前，让我们来再次回顾下上文2.1节所述的KMP算法的匹配流程：

“假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置
- 如果`j = -1`，或者当前字符匹配成功（即`S[i] == P[j]`），都令`i++，j++`，继续匹配下一个字符；
- 如果`j != -1`，且当前字符匹配失败（即`S[i] != P[j]`），则令 i 不变，`j = next[j]`。此举意味着失配时，模式串P相对于文本串S向右移动了`j - next [j]` 位。
换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值，即移动的实际位数为：`j - next[j]`，且此值大于等于1。”

1. 最开始匹配时
- P[0]跟S[0]匹配失败
 - 所以执行“如果`j != -1`，且当前字符匹配失败（即`S[i] != P[j]`），则令 i 不变，`j = next[j]`”，所以j = -1，故转而执行“如果j = -1，或者当前字符匹配成功（即`S[i] == P[j]`），都令`i++，j++`”，得到`i = 1，j = 0`，即P[0]继续跟S[1]匹配。
- P[0]跟S[1]又失配，j再次等于-1，i、j继续自增，从而P[0]跟S[2]匹配。
- P[0]跟S[2]失配后，P[0]又跟S[3]匹配。
- P[0]跟S[3]再失配，直到P[0]跟S[4]匹配成功，开始执行此条指令的后半段：“如果`j = -1`，或者当前字符匹配成功（即`S[i] == P[j]`），都令`i++，j++`”。

![image](http://490.github.io/images/20190330_195141.png)

2. P[1]跟S[5]匹配成功，P[2]跟S[6]也匹配成功, ...，直到当匹配到P[6]处的字符D时失配（即S[10] != P[6]），由于P[6]处的D对应的next 值为2，所以下一步用P[2]处的字符C继续跟S[10]匹配，相当于向右移动：`j - next[j] = 6 - 2 =4` 位。

![image](http://490.github.io/images/20190330_195157.png)

3. 向右移动4位后，P[2]处的C再次失配，由于C对应的next值为**0**，所以下一步用**P[0]**处的字符继续跟S[10]匹配，相当于向右移动：j - next[j] = 2 - 0 = 2 位。

![image](http://490.github.io/images/20190330_195213.png)

4. 移动两位之后，A 跟空格不匹配，模式串后移1 位。

![image](http://490.github.io/images/20190330_195225.png)

5. P[6]处的D再次失配，因为P[6]对应的next值为**2**，故下一步用**P[2]**继续跟文本串匹配，相当于模式串向右移动 j - next[j] = 6 - 2 = 4 位。

![image](http://490.github.io/images/20190330_195237.png)

6. 匹配成功，过程结束。

![image](http://490.github.io/images/20190330_195248.png)


  匹配过程一模一样。也从侧面佐证了，next 数组确实是只要将各个最大前缀后缀的公共元素的长度值右移一位，且把初值赋为-1 即可。

### 基于《最大长度表》与基于《next 数组》等价

我们已经知道，利用next 数组进行匹配失配时，模式串向右移动 j - next [ j ] 位，等价于已匹配字符数 - 失配字符的上一位字符所对应的最大长度值。原因是：

- j 从0开始计数，那么当数到失配字符时，j 的数值就是已匹配的字符数；
- 由于next 数组是由最大长度值表整体向右移动一位（且初值赋为-1）得到的，那么失配字符的上一位字符所对应的最大长度值，即为当前失配字符的next 值。
    
  但为何本文不直接利用next 数组进行匹配呢？因为next 数组不好求，而一个字符串的前缀后缀的公共元素的最大长度值很容易求。例如若给定模式串“ababa”，要你快速口算出其next 数组，乍一看，每次求对应字符的next值时，还得把该字符排除之外，然后看该字符之前的字符串中有最大长度为多大的相同前缀后缀，此过程不够直接。而如果让你求其前缀后缀公共元素的最大长度，则很容易直接得出结果：0 0 1 2 3，如下表格所示：


![image](http://490.github.io/images/20190330_195315.png)

然后这5个数字 全部整体右移一位，且初值赋为-1，即得到其next 数组：-1 0 0 1 2。

### Next 数组与有限状态自动机

next 负责把模式串向前移动，且当第j位不匹配的时候，用第next[j]位和主串匹配，就像打了张“表”。此外，next 也可以看作有限状态自动机的状态，在已经读了多少字符的情况下，失配后，前面读的若干个字符是有用的。

![image](http://490.github.io/images/20190330_195339.png)



